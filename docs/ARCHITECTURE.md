# System Architecture

## Overview

Quantum Trading AI is a microservices-based system designed for autonomous trading signal generation and delivery.

## Architecture Diagram

```
┌─────────────────────────────────────────────┐
│           CLIENT INTERFACES                 │
│   Web Dashboard | Telegram | WhatsApp       │
└──────────────┬──────────────────────────────┘
               │
┌──────────────▼──────────────────────────────┐
│         API GATEWAY (FastAPI)               │
│  Authentication | Rate Limiting | CORS      │
└──────────────┬──────────────────────────────┘
               │
       ┌───────┴───────┐
       │               │
┌──────▼─────┐  ┌─────▼──────┐
│  QUANTUM   │  │    MCP     │
│  ENGINE    │  │  SERVERS   │
│  (Qiskit)  │  │(Claude AI) │
└──────┬─────┘  └─────┬──────┘
       │               │
       └───────┬───────┘
               │
┌──────────────▼──────────────────────────────┐
│            DATA LAYER                       │
│  Supabase | Redis | Market Data (MT5)      │
└─────────────────────────────────────────────┘
```

## Components

### 1. Quantum Trading Engine

**Purpose**: Generate high-accuracy trading signals using quantum computing

**Technologies**:
- Qiskit: Quantum circuit simulation
- NumPy: Numerical computations
- Pandas: Data manipulation

**Key Features**:
- Quantum Phase Estimation (QPE) algorithm
- Market cycle detection
- 95%+ signal accuracy target
- Real-time and historical analysis

**Data Flow**:
1. MT5 streams market data
2. Price data encoded to quantum states
3. QPE analyzes phase patterns
4. Signals generated with confidence scores
5. Results stored in database

### 2. API Gateway

**Purpose**: RESTful API for client access

**Technologies**:
- FastAPI: High-performance async framework
- JWT: Token-based authentication
- Pydantic: Data validation

**Endpoints**:
- `/health`: System health
- `/api/v1/signals`: Trading signals
- `/api/v1/users`: User management
- `/api/v1/subscriptions`: Subscription management
- `/api/v1/analyze`: On-demand analysis

**Security**:
- JWT authentication
- Rate limiting (60/min, 1000/hour)
- CORS protection
- Input validation

### 3. Database Layer

**Purpose**: Persistent data storage

**Technologies**:
- Supabase (PostgreSQL): Primary database
- Redis: Caching and sessions

**Tables**:
- `users`: User accounts
- `subscriptions`: Subscription data
- `signals`: Trading signals
- `signal_deliveries`: Delivery tracking
- `payments`: Payment transactions
- `analytics_events`: Usage analytics

**Features**:
- Row-Level Security (RLS)
- Automatic backups
- Real-time subscriptions
- Efficient indexing

### 4. Communication Layer

**Purpose**: Multi-channel signal delivery

**Channels**:
- **Telegram**: Instant messaging with bot
- **WhatsApp**: Business messaging via Twilio
- **Email**: HTML emails via SendGrid
- **SMS**: Text messages via Twilio

**Delivery Flow**:
1. Signal generated by engine
2. Eligible users identified from database
3. Signals formatted per channel
4. Parallel delivery to all channels
5. Delivery status tracked
6. Retry logic for failures

### 5. Payment Processing

**Purpose**: Subscription billing and payments

**Technologies**:
- PayFast: South African payment gateway
- Automated billing service

**Features**:
- Multiple subscription tiers
- Automated recurring billing
- Payment verification
- Subscription lifecycle management
- Revenue tracking

### 6. MCP Servers (Business Automation)

**Purpose**: Autonomous business operations using Claude AI

**Functions**:
- Lead qualification
- Customer support automation
- Content generation
- Marketing automation
- Analytics and reporting

**Integration**:
- Anthropic Claude API
- Custom MCP protocol
- Event-driven architecture

## Data Flow: Complete Signal Lifecycle

```
1. Market Data Collection
   ↓
2. Quantum Analysis (QPE)
   ↓
3. Signal Generation
   ↓
4. Quality Validation (confidence > 75%)
   ↓
5. Database Storage
   ↓
6. User Filtering (by plan/preferences)
   ↓
7. Multi-Channel Delivery
   ↓
8. Delivery Confirmation
   ↓
9. Performance Tracking
   ↓
10. Analytics Aggregation
```

## Scaling Strategy

### Phase 1: 0-100 Users
- Single server deployment
- Free tier services
- Monolithic application
- Manual monitoring

### Phase 2: 100-500 Users
- Horizontal scaling
- Paid tier services
- Service separation
- Automated monitoring

### Phase 3: 500+ Users
- Kubernetes deployment
- Load balancing
- Microservices architecture
- Advanced observability

## Security

### Authentication
- JWT tokens with expiration
- Secure password hashing (bcrypt)
- API key management

### Data Protection
- Encryption at rest
- SSL/TLS in transit
- POPIA compliance
- Regular backups

### Rate Limiting
- Per-user quotas
- IP-based throttling
- DDoS protection

## Performance

### Targets
- API response time: <200ms (p95)
- Signal generation: <5s per symbol
- Database queries: <100ms (p95)
- Uptime: 99.9%

### Optimization
- Database indexing
- Query optimization
- Response caching (Redis)
- Async operations
- Connection pooling

## Monitoring

### Metrics
- Request latency
- Error rates
- Signal accuracy
- User engagement
- Revenue tracking

### Tools
- Logging: Loguru
- Metrics: Prometheus
- Errors: Sentry (optional)
- Uptime: Health checks

## Disaster Recovery

### Backups
- Daily database backups
- Configuration backups
- Code repository (Git)

### Recovery
- Automated failover
- Data restoration procedures
- Service restart protocols

## Deployment

### Development
```bash
docker-compose up -d
```

### Production
```bash
docker build -t quantum-trading:latest .
docker run -p 8000:8000 quantum-trading:latest
```

### CI/CD
- Automated testing
- Docker image building
- Deployment automation
- Rolling updates
